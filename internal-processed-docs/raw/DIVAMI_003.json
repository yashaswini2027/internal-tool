{
  "document_id": "DIVAMI_003",
  "raw_text": "# Advanced Git\n## Exercise Two - Staging and Stashing\n\n### Overview\nIn this exercise, we'll take a quick look at interactive staging, unstaging files, and stashing uncommitted changes.\n\n### Prerequisite\nClone the `advanced-git-exercises` repository from [github.com/nnja/advanced-git-exercises](https://github.com/nnja/advanced-git-exercises).\nThen, checkout the `exercise2` tag to set things up for the following exercise.\n\n```\n$> git clone git@github.com:nnja/advanced-git-exercises.git\nCloning into 'advanced-git-exercises'...\nremote: Counting objects: 3, done.\nremote: Total 3 (delta 0), reused 3 (delta 0), pack-reused 0\nReceiving objects: 100% (3/3), done.\nChecking connectivity... done.\n\n$> cd advanced-git-exercises\n\n$> git checkout exercise2\nSwitched to branch 'exercise2'\n```\n\n### Exercise\n1. Use `git ls-files -s` to view the contents of the staging area.\n2. Make a change and try to stage it interactively (`git add -p`).\n3. Use `git reset` to undo the staging of your file.\n4. Stash your change with a unique stash message, then unstash and apply it back to the `exercise2` branch.\n\n## Solutions\n\n### Step 1 - View the Contents of the Staging Area\n\nUnder the hood, the staging area is a file that contains a list of files, as well as the SHA1 of the version that's in the repository.\n\nUse `git ls-files -s` to view the `hello.txt` file that we checked in previously. The SHA1 hash displayed points to the blob object - which contains the contents of the file.\n\n```\n$> git ls-files -s\n100644 980a0d5f19a64b4b30a87d4206aade58726b60e3 0\thello.txt\n```\n\n\n### Step 2 - Interactive Staging\nMake a change to your `hello.txt` file, then use `git add -p` to stage your change interactively. The following is a simple example with only one change to commit. With multiple edits to a code file, for example, git will intelligently break up the changes into \"hunks.\" Git will then display sequentially and ask you whether or not you want to stage each hunk.\n\n```\n$> echo \"This is a test of the emergency git-casting system.\" >> hello.txt\n\n$> git add -p\ndiff --git a/hello.txt b/hello.txt\nindex 980a0d5..b31a35b 100644\n--- a/hello.txt\n+++ b/hello.txt\n@@ -1 +1,2 @@\n Hello World!\n+This is a test of the emergency git-casting system.\nStage this hunk [y,n,q,a,d,/,e,?]?\n```\nIf you type `?` and press `enter` after `Stage this hunk`, git will explain the shortcut keys:\n\n```\nStage this hunk [y,n,q,a,d,/,e,?]?\ny - stage this hunk\nn - do not stage this hunk\nq - quit; do not stage this hunk or any of the remaining ones\na - stage this hunk and all later hunks in the file\nd - do not stage this hunk or any of the later hunks in the file\ng - select a hunk to go to\n/ - search for a hunk matching the given regex\nj - leave this hunk undecided, see next undecided hunk\nJ - leave this hunk undecided, see next hunk\nk - leave this hunk undecided, see previous undecided hunk\nK - leave this hunk undecided, see previous hunk\ns - split the current hunk into smaller hunks\ne - manually edit the current hunk\n? - print help\n```\n\nThe change you want to change is listed above, where it says `+This is a test of the emergency git-casting system.` The `+` symbol means that a new line was added, and the following is the contents of the new line. Press `y` and `enter` to stage this hunk. You can now see that `hello.txt` has been staged to be committed.\n\n```\n$> git status\nOn branch exercise2\nYour branch is up-to-date with 'origin/exercise2'.\nChanges to be committed:\n  (use \"git reset HEAD <file>...\" to unstage)\n\n\tmodified:   hello.txt\n```\n\nNow that we've staged changes to our hello.txt file, let's run `git ls-files -s` again, to see the contents of our staging area:\n\n```\n$> git ls-files -s\n100644 b31a35bc9c5ae5aff4a0f76f7834cc2428408050 0\thello.txt\n```\n\nYou'll see that the SHA1 of `hello.txt` has changed. It _was_ `980a0` and it's now `b31a3`.\nThis mechanism is how git knows that the contents of the staging area have changed.\n\n\n### Step 3 - Unstage your Change\nSay you made a mistake while staging your changes and want to start the staging process over, but without losing the changes to your file. Use `git reset` to remove the files from the staging area, without changing the file in the working area. Use `git status` to see that our modifications to `hello.txt` are still there, but they're no longer staged for commit.\n\n```\n$> git reset hello.txt\nUnstaged changes after reset:\nM\thello.txt\n\n$> git status\nOn branch exercise2\nYour branch is up-to-date with 'origin/exercise2'.\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n\tmodified:   hello.txt\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n```\n\nThe changes to `hello.txt` are still present in the working area, but they were removed from the staging area before being committed to the repository.\n\n### Step 4 - Stash your Changes\nUse `git stash` to stash your uncommitted changes. You can unstash these changes later, when you're ready to commit them. It's a good idea to use `git stash save` with a message; this helps you remember what's what if you stash multiple changes.\n\nThen use `git status` to check the status of your working area.\n\n```\n$> git stash save \"emergency git-casting\"\nSaved working directory and index state On exercise2: emergency git-casting\nHEAD is now at aceb9e8 Initial commit\n\n$> git status\nOn branch exercise2\nYour branch is up-to-date with 'origin/exercise2'.\nnothing to commit, working directory clean\n```\n\nAs you can see, our `HEAD` is still pointed at `exercise2`, and our working directory is clean. The major benefit here is that we are now free to change branches, do other work, etc. without our changes getting in the way.\n\nNow we're ready to apply that change that we stashed. Where is it?\n\n```\n$> git stash list\nstash@{0}: On exercise2: emergency git-casting\n```\n\nUsing `git stash list` we can see that we have one stashed change - \"emergency git-casting\"\n\nWe can get more information using `git stash show`:\n\n```\n$> git stash show stash@{0}\n hello.txt | 1 +\n 1 file changed, 1 insertion(+)\n```\n\nThere's our change. Let's apply it:\n\n```\n$> git stash apply stash@{0}\nOn branch exercise2\nYour branch is up-to-date with 'origin/exercise2'.\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n\tmodified:   hello.txt\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n\n$> git diff hello.txt\ndiff --git a/hello.txt b/hello.txt\nindex 980a0d5..b31a35b 100644\n--- a/hello.txt\n+++ b/hello.txt\n@@ -1 +1,2 @@\n Hello World!\n+This is a test of the emergency git-casting system.\n```\n\nNow the change we made earlier to `hello.txt` is back in the working area, but not yet staged for commit.\n\nTip: `git stash apply` will automatically apply the last stashed change, so no need to use `stash@{0}` if you want to apply something you just stashed.\n\n#### End of Exercise Two\n"
}